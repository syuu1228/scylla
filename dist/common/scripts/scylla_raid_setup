#!/usr/bin/python2
#
# Copyright 2018 ScyllaDB
#

#
# This file is part of Scylla.
#
# Scylla is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Scylla is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Scylla.  If not, see <http://www.gnu.org/licenses/>.

import os
import argparse
import logging
import shutil
from scylla_util import *

if __name__ == '__main__':
    if os.getuid() > 0:
        logging.error('Requires root permission.')
        sys.exit(1)
    parser = argparse.ArgumentParser(description='Configure RAID volume for Scylla.')
    parser.add_argument('--disks', required=True,
                        help='specify disks for RAID')
    parser.add_argument('--raiddev', default='/dev/md0',
                        help='MD device name for RAID')
    parser.add_argument('--update-fstab', action='store_true', default=False,
                        help='update /etc/fstab for RAID')
    parser.add_argument('--root', default='/var/lib/scylla',
                        help='specify the root of the tree')
    parser.add_argument('--volume-role', default='all',
                        help='specify how will this device be used (data, commitlog, or all)')

    args = parser.parse_args()

    root = os.path.dirname(args.root)
    if args.volume_role == 'all':
        mount_at=root
    elif args.volume_role == 'data':
        mount_at='{}/data'.format(root)
    elif args.volume_role == 'commitlog':
        mount_at='{}/commitlog'.format(root)
    else:
        logging.error('Invalid role specified ({})'.format(args.volume_role))
        parser.print_help()
        sys.exit(1)

    disks = args.disks.split(',')
    for disk in disks:
        if not os.path.exists(disk):
            logging.error('{} is not found'.format(disk))
            sys.exit(1)

    if os.path.exists(args.raiddev):
        logging.error('{} is already using'.format(args.raiddev))
        sys.exit(1)

    if os.ismount(mount_at):
        logging.error('{} is already mounted'.format(mount_at))
        sys.exit(1)

    if is_debian_variant():
        run('env DEBIAN_FRONTEND=noninteractive apt-get -y install mdadm xfsprogs')
    elif is_gentoo_variant():
        run('emerge -uq sys-fs/mdadm sys-fs/xfsprogs')

    logging.info('Creating RAID0 for scylla using {} disk(s): {}'.format(len(disks), args.disks))
    if distro.id() == 'ubuntu' and distro.version() == '14.04':
        run('udevadm settle')
        run('mdadm --create --verbose --force --run {} --level=0 -c1024 --raid-devices={} {}'.format(args.raiddev, len(disks), args.disks.replace(',', ' ')))
        run('udevadm settle')
        run('mkfs.xfs {} -f'.format(args.raiddev))
    else:
        procs=[]
        for disk in disks:
            d = disk.replace('/dev/', '')
            discard_path = '/sys/block/{}/queue/discard_granularity'.format(d)
            if os.path.exists(discard_path):
                f = open(discard_path)
                discard = f.read().strip()
                f.close()
                if discard != '0':
                    proc = subprocess.Popen('blkdiscard {}'.format(disk))
                    procs.append(p)
        for proc in procs:
            proc.wait()
        run('udevadm settle')
        run('mdadm --create --verbose --force --run {} --level=0 -c1024 --raid-devices={} {}'.format(args.raiddev, len(disks), args.disks.replace(',', ' ')))
        run('udevadm settle')
        run('mkfs.xfs {} -f -K'.format(args.raiddev))

    if is_debian_variant():
        confpath = '/etc/mdadm/mdadm.conf'
    else:
        confpath = '/etc/mdadm.conf'

    res = out('mdadm --detail --scan')
    f = open(confpath, 'w')
    f.write(res)
    f.close()

    os.mkdirs(mount_at)
    run('mount -t xfs -o noatime {} "{}"'.format(args.raiddev, mount_at))

    os.mkdirs('{}/data'.format(root))
    os.mkdirs('{}/commitlog'.format(root))
    os.mkdirs('{}/coredump'.format(root))
    shutil.chown(root, 'scylla', 'scylla')
    shutil.chown('{}/data'.format(root), 'scylla', 'scylla')
    shutil.chown('{}/commitlog'.format(root), 'scylla', 'scylla')
    shutil.chown('{}/coredump'.format(root), 'scylla', 'scylla')

    if args.update_fstab:
        res = out('blkid {}'.format(args.raiddev))
        match = re.search(r'^/dev/\S+: (UUID="\S+")', res.strip())
        uuid = match.group(1)
        f = open('/etc/fstab', 'a')
        f.write('{} {} xfs noatime 0 0'.format(uuid, mount_at))
        f.close()

    if is_debian_variant():
        run('update-initramfs -u')
